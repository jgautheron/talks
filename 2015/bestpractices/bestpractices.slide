The way to Go
Gophers Katowice #1, September 28, 2015

Jonathan Gautheron
Gopher at Nexway Lab
@jgautheron
https://medium.com/@jgautheron

* About me

Past and current works:

- microservices
- cli tools
- gocha
- unexport
- go-boilerplates

.image http://golang.org/doc/gopher/gopherbw.png 200 _

* Frameworks

* Nope

.image youtellinme.jpg 500 _

* Definition

From Wikipedia:

  "A software framework is a universal, reusable software environment that provides particular
    functionality as part of a larger software platform to facilitate development of software
    applications, products and solutions."

* Frameworks:

- lock,
- constrain,
- add overheard,
- complexify,
- and are most of the time, not needed.

Only adopt heavy-duty frameworks when it becomes necessary.
Instead, you will find that a lot is already built-in the stdlib.

Examples:

- `net/http` - provides HTTP client and server implementations
- `flag` - implements command-line flag parsing

* Libraries

Use libraries instead of pulling a ton of other things that you don't need.
They focus on solving a specific problem, you can switch them easily.

Example of libraries used for a classic web app:

- `httprouter` - A high performance HTTP request router that scales well
- `Negroni` - Idiomatic HTTP Middleware
- `Render` - Easy rendering for JSON, XML, and HTML

#Most likely after a while you'll prepare a boilerplate for faster developer onboarding and standardisation.

* Configuration

* config.xml

.code config.xml

* Nope

.image settingsdawg.jpg 500 _

* Keep it stateless

Aim for no config file *at*all*.

Differences between environments?
Use environment variables (12-factor-ish).

    DB_HOST=db.local CACHE_HOST=cache.local myapp

Specific settings for a customer?
Stamp those into the build.

    go build -ldflags '\
        -X "main.bgColor=f4f4f4" \
        -X "main.logo=http://foo.com/logo.png" \
        ' -o myapp-customer

* Testing

* Packages

Most tests will be located in a `mypackage_test.go`, using the package:

    // mypackage_test.go
    package mypackage_test

This is because you want your test to behave as if they were a client of the package you're using.

For testing private members, follow the convention:

    // mypackage_internal_test.go
    package mypackage

* Table-driven tests

.code tabletests.go

* Benchmarks

.code benchmark.go

`Bench*` functions won't be executed with a regular `go`test`.

Run the benchmark methods with the following:

    go test -bench -v .

* Documentation

* Linters

* Shortlist

- *go*vet* - Reports potential errors that otherwise compile
- *go*vet*--shadow* - Reports variables that may have been unintentionally shadowed
- *gotype* - Syntactic and semantic analysis similar to the Go compiler
- *deadcode* - Finds unused code
- *gocyclo* - Computes the cyclomatic complexity of functions
- *golint* - Google's (mostly stylistic) linter
- *defercheck* - Checks for duplicate defer calls
- *varcheck* - Find unused global variables and constants
- *structcheck* - Find unused struct fields
- *errcheck* - Check that error return values are used
- *dupl* - Reports potentially duplicated code

* Checklist

* Makefile

ldflags, builds